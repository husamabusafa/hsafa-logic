---
title: Distributed Agent Platform Architecture
description: Building an Agent Builder + Distributed Agent Runtime (gateway) that scales into an agentic network (Nexuses + Entities) with persistent memory and distributed tool execution.
---

# üß† The Big Idea

You are building an **Agent Builder + Distributed Agent Runtime** that can grow into an **agentic system network**.

A system where:

* Users **create agents** via config
* Agents run **on your server** (the gateway is the runtime)
* Any client (web, mobile, node app) can:
  * Start a run
  * Watch it stream
  * Refresh and reconnect
* Agents can call **tools that run anywhere** (server, browser, other devices)

This is like giving AI agents a **backend, memory, and a network of devices**.

The update: instead of thinking only in ‚Äúone agent ‚Üî one chat‚Äù, the platform‚Äôs native model becomes **many Entities collaborating inside shared contexts** (Nexuses).

---

# üï∏Ô∏è Agentic Network Model (Nexuses + Entities)

## Core primitives

### Nexus

A **Nexus** is a shared context space (a timeline of events/messages) where participants collaborate.

- A Nexus can contain any number of participants.
- Nexuses can be public (many participants) or private (small, scoped contexts like ‚ÄúManager Nexus‚Äù).

### Entity

An **Entity** is anything that can participate in a Nexus.

- **Human Entity** (a user from your app)
- **Agent Entity** (an AI agent)
- **System Entity** (a service/backend/integration/device)

An Agent Entity can belong to multiple Nexuses.

### Client

A **Client** is a connection point where streams are delivered and responses are received.

- Examples: web browser, mobile app, Node.js backend, IoT device
- A Client is **not** an Entity ‚Äî it is a delivery channel

One Entity can connect from **multiple Clients** simultaneously. For example, a single Human Entity (user) might be logged in on both web and mobile at the same time. Both Clients receive the same stream; both can send messages as that Entity.

### Run (Agent execution)

A **Run** is one execution of **one Agent Entity** in response to a trigger that occurred inside a specific Nexus.

- A single Nexus event may trigger multiple Runs (one per Agent Entity in that Nexus).
- Each Agent decides whether to respond (an Agent may do work and then emit no user-visible message).

### Step (inside a Run)

Inside a Run, execution is a multi-step reasoning-and-acting loop:

- **Run** = a complete multi-step AI interaction
- **Step** = a single LLM call within that Run

This distinction matters because the gateway streams **partial outputs** (text deltas, tool calls, tool results) while the Run is still in progress.

## Triggers (what starts a Run)

An Agent Entity can be triggered in several ways:

* A Human Entity message inside a Nexus
* Its own scheduled Plan (proactive execution)
* Another Agent Entity inside a Nexus
* A System Entity event inside a Nexus

## Scheduling and long-term behavior

Each Agent Entity maintains:

* **Plan**: schedules future executions (cron-like). Example: ‚Äúsend a reminder at 6 PM‚Äù.
* **Goals**: short-term and long-term objectives that influence decisions over time.

The key design choice: **Plans and Goals are first-class state**, not just prompt text.

---

<details>
<summary>Architecture (later)</summary>

# üèóÔ∏è System Architecture

## 1Ô∏è‚É£ Agent Builder (Control Plane)

Users send agent configs:

```json
{
  "version": "1.0",
  "agent": {
    "name": "research-agent",
    "system": "..."
  },
  "model": {
    "provider": "openai",
    "name": "gpt-4.1-mini"
  },
  "tools": []
}
```

You:

* Store config in **durable storage**
* Reuse config when runs start

---

## 2Ô∏è‚É£ Agent Runtime (Execution Plane)

When a user starts a run:

1. Load agent config
2. Load chat history
3. Start the agent engine (the reasoning + tool loop)
4. Stream output
5. Handle tool calls
6. Save everything

Your system is the **body + memory + network**.

In the Nexus model, the gateway runtime expands slightly:

1. A message/event is written to a Nexus timeline.
2. The gateway triggers Runs for Agent Entities that belong to that Nexus.
3. Each Run streams events (text/tool-calls/tool-results) and may append new messages/events back into the Nexus.

---

</details>

# üîÅ Example scenario: Leave Request (Cross-Nexus)

A Human Entity asks an Agent Entity (in the Employee Nexus) to send a leave request to their manager.

1. The Human posts a message in the **Employee Nexus**.
2. All Agent Entities in that Nexus are triggered; only the relevant Agent chooses to respond.
3. During the same Run, the Agent calls a tool that triggers a **new Run** of itself inside a different Nexus: the **Manager Nexus**.
4. The Manager Nexus is private and contains only the Manager (Human Entity) and the Agent.
5. The Agent asks the Manager for approval.
6. The Manager replies; that reply becomes a new event in the Manager Nexus, triggering the Agent again there.
7. The Agent then triggers another Run back in the Employee Nexus to deliver the final decision.

While waiting, if the employee asks for status, the Agent can:

* Read the Manager Nexus timeline.
* Summarize progress back in the Employee Nexus.

---

# üß∞ Tool Visibility and Interaction

## Tool call visibility modes

When an Agent calls a tool, it can decide **who can see and interact with that tool call**:

### 1. Entity-visible tools

The Agent can mark a tool call as visible to **any Entity** in the Nexus (or specific Entities). This allows:

- Entities to see the tool call and its parameters
- Entities to provide a response (output) to the tool
- Collaborative workflows where multiple participants interact with the same tool execution

**Use case**: A form tool that a specific user needs to fill out, or a confirmation tool that requires approval.

### 2. Main Tools (internal)

**Main Tools** are internal tools that **no Entity should see or interact with**. These are the Agent's private capabilities for managing its own state and reasoning.

---

# üß∞ Main Tools every Agent Entity should have

These are internal tools that Entities do not see or interact with:

1. **Plan management tools**

   * Update its schedule (Plan)
   * Read its scheduled actions

2. **Goal management tools**

   * Update its Goals
   * Read its Goals

3. **Memory tools**

   * Store long-term facts, user preferences, learnings
   * Retrieve memories by topic or Entity
   * Memory persists across Runs and Nexuses

4. **Nexus awareness tools**

   * Read the list of Nexuses it belongs to
   * Read messages/events from a specific Nexus

5. **Entity awareness tools**

   * List Entities in a Nexus
   * Look up Entity info (who is this person, what are their preferences)

6. **Cross-Nexus execution tool**

   * Run itself as a new execution inside a specific Nexus
   * Include instructions about what it should do there
   * Include context about where the run originated
   * This also enables agent-to-agent collaboration: create a private Nexus between two agents, then run there to communicate

7. **Nexus management tools**

   * Create Nexuses
   * Delete Nexuses

8. **Time awareness tools**

   * Get current time
   * Understand how long ago events happened
   * Reason about deadlines and urgency

9. **Self-reflection tools**

   * Read its own past Runs
   * Summarize what it learned or did wrong
   * Track patterns in its behavior
